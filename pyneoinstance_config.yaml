db_info:
  uri: bolt://localhost:7687
  database: patient-journey-test
  user: neo4j
  password: password
initializing_queries:
  constraints:
    # lexical graph constraints
    document_id: |
      CREATE CONSTRAINT document_id IF NOT EXISTS FOR (n:Document) REQUIRE n.id IS NODE KEY;
    chunk_id: |
      CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (n:Chunk) REQUIRE n.id IS NODE KEY;
    unstructured_element_id: |
      CREATE CONSTRAINT unstructured_element_id IF NOT EXISTS FOR (n:UnstructuredElement) REQUIRE n.id IS NODE KEY;

    # domain graph constraints
    medication_name: |
      CREATE CONSTRAINT medication_name IF NOT EXISTS FOR (n:Medication) REQUIRE n.name IS NODE KEY;
    study_medication_id: |
      CREATE CONSTRAINT study_medication_id IF NOT EXISTS FOR (n:StudyMedication) REQUIRE n.id IS NODE KEY;
    medical_condition_name: |
      CREATE CONSTRAINT medical_condition_name IF NOT EXISTS FOR (n:MedicalCondition) REQUIRE n.name IS NODE KEY;
    study_population_id: |
      CREATE CONSTRAINT study_population_id IF NOT EXISTS FOR (n:StudyPopulation) REQUIRE n.id IS NODE KEY;
    clinical_outcome_id: |
      CREATE CONSTRAINT clinical_outcome_id IF NOT EXISTS FOR (n:ClinicalOutcome) REQUIRE n.id IS NODE KEY;

  indexes:
# Running the Constraint queries will create indexes for node properties of interest.
loading_queries:
  nodes:
    # lexical graph nodes
    document: |
      UNWIND $rows as row
      MERGE (n:Document {id: row.id})
      ON CREATE 
        SET n.name = row.name,
        n.source = row.source

    chunk: |
      UNWIND $rows as row
      MERGE (n:Chunk {id: row.id})
      ON CREATE 
        SET n.text = row.text,
            n.type = row.type
    
    text_element: |
      UNWIND $rows as row
      MERGE (n:TextElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number

    image_element: |
      UNWIND $rows as row
      MERGE (n:ImageElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number,
            n.imageBase64 = row.image_base64,
            n.imageMimeType = row.image_mime_type
    
    table_element: |
      UNWIND $rows as row
      MERGE (n:TableElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number,
            n.imageBase64 = row.image_base64,
            n.imageMimeType = row.image_mime_type,
            n.textAsHtml = row.text_as_html

    # domain graph nodes
    medication: |
      UNWIND $rows AS row
      MERGE (n:Medication {name: row.name})
      SET n.medication_class = COALESCE(n.medication_class, row.medication_class), 
          n.mechanism = COALESCE(n.mechanism, row.mechanism), 
          n.genericName = COALESCE(n.genericName, row.generic_name), 
          n.brandNames = COALESCE(n.brandNames, row.brand_names), 
          n.approvalStatus = COALESCE(n.approvalStatus, row.approval_status)

    study_medication: |
      UNWIND $rows AS row
      MERGE (n:StudyMedication {id: row.study_medication_id})
      SET n.studyName = COALESCE(n.studyName, row.study_name),
          n.treatmentArm = COALESCE(n.treatmentArm, row.treatment_arm),
          n.dosage = COALESCE(n.dosage, row.dosage), 
          n.route = COALESCE(n.route, row.route), 
          n.frequency = COALESCE(n.frequency, row.frequency), 
          n.treatmentDuration = COALESCE(n.treatmentDuration, row.treatment_duration), 
          n.comparator = COALESCE(n.comparator, row.comparator), 
          n.adherenceRate = COALESCE(n.adherenceRate, row.adherence_rate), 
          n.formulation = COALESCE(n.formulation, row.formulation)
    
    clinical_outcome: |
      UNWIND $rows AS row
      MERGE (n:ClinicalOutcome {id: row.clinical_outcome_id})
      SET n.studyName = COALESCE(n.studyName, row.study_name),
          n.name = COALESCE(n.name, row.name)

    medical_condition: |
      UNWIND $rows AS row
      MERGE (n:MedicalCondition {name: row.name})
      SET n.category = COALESCE(n.category, row.category), 
          n.severity = COALESCE(n.severity, row.severity), 
          n.icd10Code = COALESCE(n.icd10Code, row.icd10_code), 
          n.duration = COALESCE(n.duration, row.duration), 
          n.prevalence = COALESCE(n.prevalence, row.prevalence)
    
    study_population: |
      UNWIND $rows AS row
      MERGE (n:StudyPopulation {id: row.study_population_id})
      SET n.description = COALESCE(n.description, row.description), 
          n.studyName = COALESCE(n.studyName, row.study_name),
          n.minAge = COALESCE(n.minAge, row.min_age), 
          n.maxAge = COALESCE(n.maxAge, row.max_age), 
          n.malePercentage = COALESCE(n.malePercentage, row.male_percentage), 
          n.femalePercentage = COALESCE(n.femalePercentage, row.female_percentage), 
          n.otherGenderPercentage = COALESCE(n.otherGenderPercentage, row.other_gender_percentage), 
          n.sampleSize = COALESCE(n.sampleSize, row.sample_size), 
          n.studyType = COALESCE(n.studyType, row.study_type), 
          n.location = COALESCE(n.location, row.location), 
          n.inclusionCriteria = COALESCE(n.inclusionCriteria, row.inclusion_criteria), 
          n.exclusionCriteria = COALESCE(n.exclusionCriteria, row.exclusion_criteria), 
          n.studyDuration = COALESCE(n.studyDuration, row.study_duration)

  relationships:
    # lexical graph relationships
    chunk_part_of_document: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (d:Document {id: row.document_id})
      MERGE (c)-[:PART_OF_DOCUMENT]->(d)

    unstructured_element_part_of_chunk: |
      UNWIND $rows as row
      MATCH (u:UnstructuredElement {id: row.unstructured_element_id})
      MATCH (c:Chunk {id: row.chunk_id})
      MERGE (u)-[:PART_OF_CHUNK]->(c)
    
    chunk_has_next_chunk: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.source_id})
      MATCH (n:Chunk {id: row.target_id})
      MERGE (c)-[:HAS_NEXT_CHUNK]->(n)

    # domain graph relationships
    # -- this relationship also links to patient journey graph
    study_medication_uses_medication: |
      UNWIND $rows as row
      MATCH (s:StudyMedication {id: row.study_medication_id})
      MATCH (m:Medication {name: row.medication_name})
      MERGE (s)-[:USES_MEDICATION]->(m)

    study_medication_produces_clinical_outcome: |
      UNWIND $rows as row
      MATCH (s:StudyMedication {id: row.study_medication_id})
      MATCH (o:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (s)-[:PRODUCES_CLINICAL_OUTCOME]->(o)

    study_population_has_medical_condition: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (m:MedicalCondition {name: row.medical_condition_name})
      MERGE (s)-[:HAS_MEDICAL_CONDITION]->(m)

    study_population_receives_study_medication: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (m:StudyMedication {id: row.study_medication_id})
      MERGE (s)-[:RECEIVES_STUDY_MEDICATION]->(m)

    study_population_has_clinical_outcome: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (o:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (s)-[:HAS_CLINICAL_OUTCOME]->(o)

    
    # linking lexical and domain graphs
    chunk_has_entity_medication: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:Medication {name: row.name})
      MERGE (c)-[:HAS_ENTITY]->(e)
    
    chunk_has_entity_medical_condition: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:MedicalCondition {name: row.name})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_study_medication: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:StudyMedication {id: row.study_medication_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_study_population: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:StudyPopulation {id: row.study_population_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_clinical_outcome: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (c)-[:HAS_ENTITY]->(e)
    
    # linking domain graph to patient journey graph
    demographic_in_study_population: |
      MATCH (d:Demographic)
      MATCH (s:StudyPopulation)
      // sex and age are in study population and match
      CALL (d, s) {
          WITH d, s
          WHERE s.minAge IS NOT NULL
              AND d.age >= s.minAge 
              AND s.maxAge IS NOT NULL
              AND d.age <= s.maxAge
              AND (
                  (d.sex = "M" AND s.malePercentage IS NOT NULL) OR
                  (d.sex = "F" AND s.femalePercentage IS NOT NULL) OR
                  (d.sex <> "M" AND d.sex <> "F" AND s.otherGenderPercentage IS NOT NULL)
              )
          MERGE (d)-[r:IN_STUDY_POPULATION]->(s)
          ON CREATE
              SET r.fit = 1.0
      }
      // sex or age are in study population and match
      CALL (d, s) {
          WITH d, s
          WHERE (
              (s.minAge IS NOT NULL AND d.age >= s.minAge AND s.maxAge IS NOT NULL AND d.age <= s.maxAge AND
              s.malePercentage IS NULL AND s.femalePercentage IS NULL AND s.otherGenderPercentage IS NULL) OR
              
              (s.minAge IS NULL AND s.maxAge IS NULL AND
              ((d.sex = "M" AND s.malePercentage IS NOT NULL) OR
                (d.sex = "F" AND s.femalePercentage IS NOT NULL) OR
                (d.sex <> "M" AND d.sex <> "F" AND s.otherGenderPercentage IS NOT NULL)))
          )
          MERGE (d)-[r:IN_STUDY_POPULATION]->(s)
          ON CREATE
              SET r.fit = 0.5
      }



processing_queries:
  get_chunk_nodes_to_process_by_article_name: |
    MATCH (d:Document {name: $article_name})<-[:PART_OF_DOCUMENT]-(c:Chunk)
    RETURN c.id as id, c.text as text
  
  get_chunk_nodes_to_process: |
    MATCH (c:Chunk)
    WHERE c.text IS NOT NULL
      AND c.embedding IS NULL
      AND size(c.text) >= $min_length
    RETURN c.id as id, c.text as text