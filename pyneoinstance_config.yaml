db_info:
  uri: bolt://localhost:7687
  database: test-many-articles
  user: neo4j
  password: password
initializing_queries:
  constraints:
    # lexical graph constraints
    document_id: |
      CREATE CONSTRAINT document_id IF NOT EXISTS FOR (n:Document) REQUIRE n.id IS NODE KEY;
    # document_pmid: |
    #   CREATE CONSTRAINT document_pmid IF NOT EXISTS FOR (n:Document) REQUIRE n.pmId IS NODE KEY;
    # document_name: |
    #   CREATE CONSTRAINT document_name IF NOT EXISTS FOR (n:Document) REQUIRE n.name IS NODE KEY;

    chunk_id: |
      CREATE CONSTRAINT chunk_id IF NOT EXISTS FOR (n:Chunk) REQUIRE n.id IS NODE KEY;

    unstructured_element_id: |
      CREATE CONSTRAINT unstructured_element_id IF NOT EXISTS FOR (n:UnstructuredElement) REQUIRE n.id IS NODE KEY;

    # domain graph constraints
    # medication_id: |
    #   CREATE CONSTRAINT medication_id IF NOT EXISTS FOR (n:Medication) REQUIRE n.id IS UNIQUE;
    medication_name: |
      CREATE CONSTRAINT medication_name IF NOT EXISTS FOR (n:Medication) REQUIRE n.name IS NODE KEY;
    study_medication_id: |
      CREATE CONSTRAINT study_medication_id IF NOT EXISTS FOR (n:StudyMedication) REQUIRE n.id IS UNIQUE;
    # medical_condition_id: |
    #   CREATE CONSTRAINT medical_condition_id IF NOT EXISTS FOR (n:MedicalCondition) REQUIRE n.id IS UNIQUE;
    medical_condition_name: |
      CREATE CONSTRAINT medical_condition_name IF NOT EXISTS FOR (n:MedicalCondition) REQUIRE n.name IS NODE KEY;
    study_population_id: |
      CREATE CONSTRAINT study_population_id IF NOT EXISTS FOR (n:StudyPopulation) REQUIRE n.id IS UNIQUE;
    study_population_name: |
      CREATE CONSTRAINT study_population_name IF NOT EXISTS FOR (n:StudyPopulation) REQUIRE n.name IS NODE KEY;
    study_outcome_id: |
      CREATE CONSTRAINT study_outcome_id IF NOT EXISTS FOR (n:StudyOutcome) REQUIRE n.id IS UNIQUE;
    study_outcome_name: |
      CREATE CONSTRAINT study_outcome_name IF NOT EXISTS FOR (n:StudyOutcome) REQUIRE n.name IS NODE KEY;

  indexes:
# Running the Constraint queries will create indexes for node properties of interest.
loading_queries:
  nodes:
    # lexical graph nodes
    document: |
      UNWIND $rows as row
      MERGE (n:Document {id: row.id})
      ON CREATE 
        SET n.name = row.name,
        n.source = row.source

    chunk: |
      UNWIND $rows as row
      MERGE (n:Chunk {id: row.id})
      ON CREATE 
        SET n.text = row.text,
            n.type = row.type
    
    text_element: |
      UNWIND $rows as row
      MERGE (n:TextElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number

    image_element: |
      UNWIND $rows as row
      MERGE (n:ImageElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number,
            n.imageBase64 = row.image_base64,
            n.imageMimeType = row.image_mime_type
    
    table_element: |
      UNWIND $rows as row
      MERGE (n:TableElement {id: row.id})
      ON CREATE 
        SET n:UnstructuredElement,
            n.text = row.text, 
            n.type = row.type, 
            n.pageNumber = row.page_number,
            n.imageBase64 = row.image_base64,
            n.imageMimeType = row.image_mime_type,
            n.textAsHtml = row.text_as_html

    # domain graph nodes
    medication: |
      UNWIND $rows AS row
      MERGE (n:Medication {name: row.name})
      SET n.medication_class = COALESCE(n.medication_class, row.medication_class), 
          n.mechanism = COALESCE(n.mechanism, row.mechanism), 
          n.generic_name = COALESCE(n.generic_name, row.generic_name), 
          n.brand_names = COALESCE(n.brand_names, row.brand_names), 
          n.approval_status = COALESCE(n.approval_status, row.approval_status)

    study_medication: |
      UNWIND $rows AS row
      MERGE (n:StudyMedication {id: row.study_medication_id})
      SET n.studyName = COALESCE(n.studyName, row.study_name),
          n.dosage = COALESCE(n.dosage, row.dosage), 
          n.route = COALESCE(n.route, row.route), 
          n.frequency = COALESCE(n.frequency, row.frequency), 
          n.treatmentDuration = COALESCE(n.treatmentDuration, row.treatment_duration), 
          n.treatmentArm = COALESCE(n.treatmentArm, row.treatment_arm), 
          n.comparator = COALESCE(n.comparator, row.comparator), 
          n.adherenceRate = COALESCE(n.adherenceRate, row.adherence_rate), 
          n.formulation = COALESCE(n.formulation, row.formulation)
    
    clinical_outcome: |
      UNWIND $rows AS row
      MERGE (n:ClinicalOutcome {id: row.clinical_outcome_id})
      SET n.category = COALESCE(n.category, row.category), 
          n.description = COALESCE(n.description, row.description), 
          n.measurementUnit = COALESCE(n.measurementUnit, row.measurement_unit), 
          n.normalRange = COALESCE(n.normalRange, row.normal_range), 
          n.baselineValue = COALESCE(n.baselineValue, row.baseline_value), 
          n.postTreatmentValue = COALESCE(n.postTreatmentValue, row.post_treatment_value), 
          n.changeFromBaseline = COALESCE(n.changeFromBaseline, row.change_from_baseline), 
          n.pValue = COALESCE(n.pValue, row.p_value), 
          n.confidenceInterval = COALESCE(n.confidenceInterval, row.confidence_interval), 
          n.effectSize = COALESCE(n.effectSize, row.effect_size)

    medical_condition: |
      UNWIND $rows AS row
      MERGE (n:MedicalCondition {name: row.name})
      SET n.category = COALESCE(n.category, row.category), 
          n.severity = COALESCE(n.severity, row.severity), 
          n.icd10Code = COALESCE(n.icd10Code, row.icd10_code), 
          n.duration = COALESCE(n.duration, row.duration), 
          n.prevalence = COALESCE(n.prevalence, row.prevalence)
    
    study_population: |
      UNWIND $rows AS row
      MERGE (n:StudyPopulation {id: row.study_population_id})
      SET n.description = COALESCE(n.description, row.description), 
          n.ageRange = COALESCE(n.ageRange, row.age_range), 
          n.meanAge = COALESCE(n.meanAge, row.mean_age), 
          n.malePercentage = COALESCE(n.malePercentage, row.male_percentage), 
          n.femalePercentage = COALESCE(n.femalePercentage, row.female_percentage), 
          n.otherGenderPercentage = COALESCE(n.otherGenderPercentage, row.other_gender_percentage), 
          n.sampleSize = COALESCE(n.sampleSize, row.sample_size), 
          n.studyType = COALESCE(n.studyType, row.study_type), 
          n.location = COALESCE(n.location, row.location), 
          n.inclusionCriteria = COALESCE(n.inclusionCriteria, row.inclusion_criteria), 
          n.exclusionCriteria = COALESCE(n.exclusionCriteria, row.exclusion_criteria), 
          n.studyDuration = COALESCE(n.studyDuration, row.study_duration)

  relationships:
    # lexical graph relationships
    chunk_part_of_document: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (d:Document {id: row.document_id})
      MERGE (c)-[:PART_OF_DOCUMENT]->(d)

    unstructured_element_part_of_chunk: |
      UNWIND $rows as row
      MATCH (u:UnstructuredElement {id: row.unstructured_element_id})
      MATCH (c:Chunk {id: row.chunk_id})
      MERGE (u)-[:PART_OF_CHUNK]->(c)
    
    chunk_has_next_chunk: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.source_id})
      MATCH (n:Chunk {id: row.target_id})
      MERGE (c)-[:HAS_NEXT_CHUNK]->(n)

    # domain graph relationships
    study_medication_uses_medication: |
      UNWIND $rows as row
      MATCH (s:StudyMedication {id: row.study_medication_id})
      MATCH (m:Medication {name: row.medication_name})
      MERGE (s)-[:USES_MEDICATION]->(m)

    study_medication_produces_clinical_outcome: |
      UNWIND $rows as row
      MATCH (s:StudyMedication {id: row.study_medication_id})
      MATCH (o:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (s)-[:PRODUCES_CLINICAL_OUTCOME]->(o)

    study_population_has_medical_condition: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (m:MedicalCondition {name: row.medical_condition_name})
      MERGE (s)-[:HAS_MEDICAL_CONDITION]->(m)

    study_population_receives_study_medication: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (m:StudyMedication {id: row.study_medication_id})
      MERGE (s)-[:RECEIVES_STUDY_MEDICATION]->(m)

    study_population_has_clinical_outcome: |
      UNWIND $rows as row
      MATCH (s:StudyPopulation {id: row.study_population_id})
      MATCH (o:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (s)-[:HAS_CLINICAL_OUTCOME]->(o)

    
    # linking lexical and domain graphs
    chunk_has_entity_medication: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:Medication {name: row.name})
      MERGE (c)-[:HAS_ENTITY]->(e)
    
    chunk_has_entity_medical_condition: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:MedicalCondition {id: row.medical_condition_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_study_medication: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:StudyMedication {id: row.study_medication_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_study_population: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:StudyPopulation {id: row.study_population_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

    chunk_has_entity_clinical_outcome: |
      UNWIND $rows as row
      MATCH (c:Chunk {id: row.chunk_id})
      MATCH (e:ClinicalOutcome {id: row.clinical_outcome_id})
      MERGE (c)-[:HAS_ENTITY]->(e)

processing_queries:
  get_chunk_nodes_to_process_by_article_name: |
    MATCH (d:Document {name: $article_name})<-[:PART_OF]-(c:Chunk)
    RETURN c.id as id, c.text as text
  
  get_chunk_nodes_to_process: |
    MATCH (c:Chunk)
    WHERE c.text IS NOT NULL
      AND c.embedding IS NULL
      AND size(c.text) >= $min_length
    RETURN c.id as id, c.text as text